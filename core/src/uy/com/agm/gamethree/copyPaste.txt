--------------------------- code copy paste ---------------------------------------
para items los cast
para vidas heal

armas
https://mrbubblewand.wordpress.com/2010/12/30/animation-light_004/ yo
https://mrbubblewand.wordpress.com/2010/04/11/animation-light_003/ enemigo
https://mrbubblewand.wordpress.com/2010/01/29/animation-wind_002/
https://mrbubblewand.wordpress.com/2010/01/28/animation-magic_005/
https://mrbubblewand.wordpress.com/2010/01/18/animation-magic_004/
https://mrbubblewand.wordpress.com/2009/10/05/animation-fire_002/
https://mrbubblewand.wordpress.com/2009/09/13/animation-magic_003/
https://mrbubblewand.wordpress.com/2009/06/09/animation-effect_001/
https://mrbubblewand.wordpress.com/2009/06/07/animation-magic_02/
https://mrbubblewand.wordpress.com/2009/06/05/animations-thunder_01-heal_01-2/

candidatos a poderes del malo:
effect_001 tiene fondo negro
wind_003 queda bien
thunder_003 queda hermoso pero es cuadrado :(
heal_003 no queda muy lindo, no se destaca.
magic_008 no queda muy lindo, no se destaca.

posibles audios ante la perdida de poder
https://freesound.org/people/Streetpoptunez/sounds/413074/
https://freesound.org/people/KauaiBoyRK/sounds/59545/
https://freesound.org/people/OwlStorm/sounds/404767/
https://freesound.org/people/suntemple/sounds/253173/
https://freesound.org/people/Callum_Sharp279/sounds/200469/
https://freesound.org/people/Veiler/sounds/264462/ (bump)

posibles poderes
https://mrbubblewand.files.wordpress.com/2009/08/special_002.png
https://mrbubblewand.files.wordpress.com/2010/02/magic_006.png
https://mrbubblewand.files.wordpress.com/2010/01/magic_005.png
https://mrbubblewand.files.wordpress.com/2010/01/magic_004.png
https://mrbubblewand.files.wordpress.com/2009/09/magic_003.png
https://mrbubblewand.files.wordpress.com/2009/08/magic_002.png (fondo negro)
https://mrbubblewand.files.wordpress.com/2009/08/heal_001.png
https://mrbubblewand.files.wordpress.com/2009/08/darkness_001.png

posibles efectos para escudos
escudo
https://mrbubblewand.files.wordpress.com/2010/06/fire_003.png si
https://mrbubblewand.files.wordpress.com/2009/10/water_003.png puede ser
https://mrbubblewand.files.wordpress.com/2010/05/earth_002.png no
https://mrbubblewand.files.wordpress.com/2010/01/magic_004.png
https://mrbubblewand.files.wordpress.com/2010/02/magic_006.png puede ser

-----------------------------------------------------------------------------------
FUNCION SENO
  private float getNewX(float x, float y, float dt) {
        return (float) Math.sin(2.0f * y - dt) * Constants.V_WIDTH / Constants.PPM;
    }

    private Vector2 getNewVelocity(float yActual, float dt) {
        /*
        origen = (b2body.getPosition().x, 2body.getPosition().y)
        destino = (getNewX(b2body.getPosition().x, b2body.getPosition().y, dt), b2body.getPosition().y - dt)
        destino - origen = ()
         */
        velocity = new Vector2();
        velocity.x = getNewX(b2body.getPosition().x, b2body.getPosition().y, dt) - b2body.getPosition().x;
        velocity.y = dt;
        velocity.nor();
        velocity.x = velocity.x * 4.0f;
        velocity.y = -velocity.y * 4.0f;
        return velocity;
    }

	luego......

	 private void stateAlive(float dt) {
        b2body.setLinearVelocity(getNewVelocity(b2body.getPosition().y, dt));

        /* Update our Sprite to correspond with the position of our Box2D body:
        * Set this Sprite's position on the lower left vertex of a Rectangle determined by its b2body to draw it correctly.
        * At this time, EnemyOne may have collided with sth. and therefore it has a new position after running the physical simulation.
        * In b2box the origin is at the center of the body, so we must recalculate the new lower left vertex of its bounds.
        * GetWidth and getHeight was established in the constructor of this class (see setBounds).
        * Once its position is established correctly, the Sprite can be drawn at the exact point it should be.
         */
        setPosition(b2body.getPosition().x - getWidth() / 2, b2body.getPosition().y - getHeight() / 2);
        setRegion((TextureRegion) enemyOneAnimation.getKeyFrame(stateTime, true));
        stateTime += dt;
        openFireTime += dt;
        if (openFireTime > Constants.ENEMYONE_FIRE_DELAY_SECONDS) {

Para ir a pelear directo con el enemigo final poner en playscreen:
        // Initially set our gamcam to be centered correctly at the start (bottom) of the map
        //gameCam.position.set(gameViewPort.getWorldWidth() / 2, gameViewPort.getWorldHeight() / 2, 0);
        gameCam.position.set(gameViewPort.getWorldWidth() / 2, 75, 0);

        // Create the hero in our game world
        player = new Hero(this, gameCam.position.x, gameCam.position.y / 2);
        player.getB2body().setTransform(this.getGameCam().position.x, this.getGameCam().position.y - this.getGameViewPort().getWorldHeight() / 4, player.getB2body().getAngle()); // todo

02-02 18:00:30.905 8532-8600/uy.com.agm.gamethree D/uy.com.agm.gamethree.sprites.finals.FinalEnemyLevelOne: UPPER Y POS 79.98127 79.40.6

----------------

MOVIMIENTOS COMPLEJOS:

1) Para hacer ochos y eso.

    private Vector2 getNewTangentialSpeed(float dt) {
        elapsedTime += dt;

        if (elapsedTime >= period) {
            elapsedTime = 0;
            counterclockwise = !counterclockwise;
        }


        float w = 2 * MathUtils.PI / period;
        tmp.set((!counterclockwise ? -1 : 1) * radius * w * MathUtils.sin(w * elapsedTime), (!counterclockwise ? -1 : 1)*radius * w * MathUtils.cos(w * elapsedTime));
        //tmp.set((counterclockwise ? -1 : 1)*radius * w * MathUtils.cos(w * elapsedTime),(counterclockwise ? -1 : 1) * radius * w * MathUtils.sin(w * elapsedTime));
        Gdx.app.debug(TAG, "****" + tmp.x + " " + tmp.y + " ELAPSED_TIME " + elapsedTime);
        return tmp;
    }

2)
elapsedTime += dt;
	float w = 2 * MathUtils.PI / PERIOD_SECONDS;

	float t = elapsedTime;


	curva sin derivar:
	2 sin (w t), 2 cos (w t/2)

	Es como una especie de 8 medio chato. No tiene gran gracia.

	derivada
	2wcos(wt), -2wsin(wt/2)/2

    private float sin(float x) {
        return MathUtils.sin(x);
    }
    private float cos(float x) {
        return MathUtils.cos(x);
    }
------------------------------------------------------------------
	otra mas linda:
	x = 3 cos(2wt)cos(wt)
	y = 3 cos(2wt)sin(wt)

	derivada:
	-3w(2cos(wt)sin(2wt)+sin(wt)cos(2wt))
	-3w(2sin(wt)sin(2wt)-cos(wt)cos(2wt))

	es una florcita de 4 petalos.

        elapsedTime += dt;
        float w = 2 * MathUtils.PI / PERIOD_SECONDS;

        float t = elapsedTime;
        float x = -3*w*(2*cos(w*t)*sin(2*w*t)+sin(w*t)*cos(2*w*t));
        float y = -3*w*(2*sin(w*t)*sin(2*w*t)-cos(w*t)*cos(2*w*t));
        tmp.set(x, y);
        return tmp;
------------------------------------------------------------------
	es el movimiento ese en forma de cometa

		solucion final:

		en el constructor
		counterclockwise = (b2body.getPosition().x < screen.getGameCam().position.x) ? false : true;

		en el metodo de velocidad:

        // parametrica: t**3-3.2t+2, 2t**2
        elapsedTime += dt / 3; <----- aca le puse /3 para reducir la velocidad, NO LOGRE HACERLO DE OTRA MANERA (NI USANDO W).
        float max = 2.497f;
        float min = -2.497f;
        float t = (max - min) * elapsedTime + min;
        float x = (3*t*t - 4.5f) * (counterclockwise ? -1:1);
        float y = 4 * t;
        tmp.set(x, y);
        return tmp;

		en el stateAlive:
		if (b2body.isActive()) {
            velocity.set(getNewTangentialSpeed(dt));
        }
