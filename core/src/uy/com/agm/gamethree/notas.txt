TILESET
-------
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

CUSTOM PROPERTIES
-----------------
enemyBullet
powerOne
strength (int)
powerTwo

IDEAS
-----
- programar acelerómetro?
- Cuando explota un enemigo puedo hacer aparecer 2 enemigos
- Cuando le disparo a un enemigo, no explota sino que se queda quieto (o se congela con efecto) y luego revive.

ALCANCE
-------
- El level tiene puentes
Hay 2 tipos de elementos:
	1) bola de poder
		- *nada
		- escudo (shield_blue.gif esta muy bueno)
		- invisibilidad (seria algo así como que puedo caminar por toda la pantalla sin colisionar
		  con anda)
		- detener pantalla (por tiempo)
		- te pones rojo y chocas a todos (por tiempo) (puedo hacer que choques a todos y ademas te reboten las balas, rodeado de fuego)
		- *invulnerabilidad (te rodea una burbuja) es por tiempo
		- matar a todos de una vez.
	2) bola de armas
		- nada
		- boomeran
		- triple bola de fuego
		- doble fecha
		- flecha simple (arma por defecto)

Bloques con sorpresas

enemigo1: bolas negras que bajan derecho
		  luego disparan
enemigo2: bandada murcielagos
		  luego disparan
		  luego vienen desfazados los murcielagos
enemigo3: caballeros que bajan derecho luego se mueven un poco a la derecha o la izquierda y luego bajan de nuevo y disparan
enemigo4: nubes (viajan tranqui como funcion seno (sobre eje x) y luego se te tiran arriba rapido)

PROXIMOS PASOS
--------------
- ponerle sonido y assets bien

PENDIENTES
----------
- las properties del tilededitor pueden ser boolean, usarlas.
- tendria que agregar otra layer para los puentes porque por ej. las balas desaparecen al chocar con
bordes y objetos
- averiguar como debuguear
- optimizar el movimiento de hero usando setRotation, setOriginCenter y setFlip. No puedo, todos mis intentos quedan peor.
- sigo sin entender mucho por que la camara no dibuja el ultimo cachito.
- estaría bueno que las balas reboten y los enemigos también en modo ghost, capaz mejor cuando haga otro poder.
- comprar el ninja?
- renombrar los audios con nomenclatura
- VER QUE HAYAN QUEDADO BIEN CENTRADAS LAS EXPLOSIONES DE LOS ENEMIGOS. LA DE LA POWERBOX QUEDO BIEN.
- capaz me conviene agrupar las constantes en clases estaticas para cada objeto....no se..como hice assets
- cuando haga varios niveles, voy a tener que cargar varios maps. Hacer lo mismo que se hizo con AssetsSounds o sea, se carga todo en la clase Assets y luego se hace otra clase (AssetsSounds)
que devuelve cada sonido. En mi caso sería otra clase AssetsLevels que retorna map1 map2 map3 etc.

TENGO LAS SIGUIENTES CUSTOM PROPERTIES
--------------------------------------
powerOne
enemyBullet
strength 3

DUDAS
-----
- Que se ejecuta primero el update o el draw?
For instance, within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled by the distance
traveled in time "delta" (it doesn't render them, just moves their position variables).
Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta),
which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.
- git:
    traer un solo fuente (con sourcetree)
    ver diferencias de mi fuente actual con el del repositorio
    abrir un git local (un proyecto) sin tener que hacer clone
    No me quedo un acceso directo, sino que ejecuto el exe que baje
- No se donde tengo que hacer Assets.dispose(), lo puse en gamethree
- Manejo de memoria y uso de Vector2.
- Me queda el problema de que cuando dejas el dedo apoyado hero se enloquece.


VIDEO
-----
FELICITACIONES

HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames
- http://www.online-image-editor.com/: editor en linea
- sourceTree para administrar git
- https://audio.online-convert.com/es/convertir-a-ogg: conversor de mp3 a ogg
- https://github.com/BrentAureli/SuperMario / https://www.patreon.com/BrentAureli
- https://freesound.org, user aclaveri/2es...etc. Para sonido.
- https://www.youtube.com/watch?v=dxPf1M7YORU&feature=youtu.be para crear fonts ver ese video
- https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php para cortar una imagen en pedazos iguales

METODOLOGIA
-----------
1)
    Posicon + velocidad da posicion
    Para ir de A a B, debo restar los vectores B - A.
    La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

    Vector2 position = new Vector2();
    Vector2 velocity = new Vector2();
    Vector2 acceleration = new Vector2(0, -10);
    while(simulationRuns) {
        float deltaTime = getDeltaTime();
        velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
    }
    This is called numerical Euler integration, and it is the most intuitive of the integration methods
    used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
    of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
    movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
    loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
    then update the position, based on the velocity multiplied by the delta time. That’s all there is to
    the big, scary word integration.

2)
    Personaje a partir de gif animado:
    - Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
    - Abrir cada imagen con Paint.net y ponerle fondo transparente.
    - Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
    - Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc.
    - Usar el TexturePacker para unirlas todas.

    Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
    - Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
    - Usar el TexturePacker para unirlas todas.

3)
    Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
    En las layers (tiled) pongo un rectangulo de cualquier tamano.
    Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
    Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
    Ese tamanio son pixels / (pixels / metro) o sea, metros.
    Entonces no importaria el tamano del rectangulo en las layers.

6)
    SISTEMA DE COORDENADAS
    ----------------------
    SPRITE:
    setPosition(x,y) indica el vertice inferior izquierdo de un rectangulo definido con setBounds.
    setBounds(x, y, width, hegiht) indica un rectangulo cuyo vertice inferior izquierdo esta en x, y.
    Siempre debo trabajar con coordenadas del mundo (no pixels).
    En otras palabras, el origen de coordenadas esta en su vertice inferior izquierdo.

    CAMARA:
    La camara tiene como origen de coordenadas su centro, es decir, el centro de la pantalla es (cam.x, cam.y).

    BOX2D
    Los objetos de box2d (b2body) tienen como origen de coordenadas su centro.
    Es decir su centro es (b2body.getPosition().x, b2body.getPosition().y).

    MUNDO
    Su origen de coordenadas esta en su esquina inferior izquierda.
    Identico a SPRITE.

    TOUCH EVENTOS
    Su origen está en la esquina superior izquierda (lpmqtp)
    Es decir, el (0, 0) esta arriba a la izquierda.

    TEXTURAS
    Tienen un u y v. No recuerdo exactamente. Es otro caso distinto.

7)
    Para levantar proyecto github:
    - instalar java 8 y definir JAVA_HOME
    - instalar android sdk y definir ANDROID_HOME (pues la usa git)
    - instalar git y agregarlo al PATH. Definir su proxy:
    git config --global http.proxy http://amorales:tqspy.7719@proxy.bse.com.uy:8080
    - instalar maven y agregarlo al PATH
    - instalar android studio y en settings apuntar a la instalación de git. Definir su proxy, puse el del bse.
    - abrir android studio, open new project y seleccionar la carpeta androidStudioProjects.
    - luego checkout (vcs/checkout from version control) desde github: https://github.com/agmCorp/GameThree (https://github.com/BrentAureli/SuperMario)
    - cerrar andoid studio
    /* esto podría no ser necesario
    - ir a dos, dentro de gamethree:
    gradlew -Dhttp.proxyHost=proxy.bse.com.uy -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.bse.com.uy -Dhttps.proxyPort=8080 build
    Si es para supermario, puede ser que me falte alguna cosa de android, ahí tengo que abrir el sdk manager y bajarla.
    */
    - abrir andoid studio, darle luego open y seleccionar el archivo build.grandle, ahí pide proxy meter el del bse.
    - en settings deshabilitar configuration on demand
    - luego view/windows tools/gradle
    - luego dalre sincronizar, esperar que finalice  la indexacion
    Si le falta alguna librería de andoid, en el error da un link en donde pinchás y te la instala en c\users\amorales\appdata\local\android\sdk.
    Sino el sdk Manager está en el menú tools/Android y ahí las cargo yo a mano hasta resolver todos los problemas.
    Tuve que editar el build.grandle de super mario y poner com.android.tools.build:gradle:2.3.0 en lugar de com.android.tools.build:gradle:2.3.0-beta1
    - cerrar el android studio, abrir el proyecto, crear el run deskotp, luego darle run y pide module, ponerle desktop.
    - la pc de mi trabajo no soporta opengl2.0 así que solo puedo ejecutar en android.

8)
   git fetch origin
   git reset --hard origin/master

   Puedo hacer un git pull, pero capaz lo mejor es hacer:
   git fetch // trae cambios pero no los aplica
   git diff // me muestra los cambios
   git merge // ejecuta cambios

   usar Sourcetree: Reset current branch to this commit
   Con eso hago un update forzado sobreescribiendo el local con el remoto.

9)
    Para generar el jar y correrlo en pc, dentro del proyecto ejecutar:
    gradlew desktop:dist

    El jar queda en GameThree\desktop\build\libs

10)
    Para generar un BitmapFont usar SoeBox.
    Abrirlo y apretar "Bitmap Font". Eso copia al portapapeles un conjunto de letras.
    Abrir un editor grafico, seleccionar la herramienta para insertar texto y darle pegar.
    Eso pega todos los caracteres en pantalla, luego los edito como quiera cambiando colores, etc.
    Finalmente al png resultante, lo tiro nuevamente en la herramienta sobre "Bitmap Font", eso detecta
    los caracteres.
    Luego, para evitar tener que editar las settings a mano, debo apretar el boton "Auto fit Settings". Eso setea
    las propiedades de alto y ancho de cada letra para que se vea bien.
    Al salvar genera 2 archivos los cuales uso. Capaz que tengo que editarlos para cambiar una ruta absoluta que
    aparece alli (como en TiledEditor).

11)
    Para definir el tamaño (ancho y altura) de un sprite, debo usar setBoundaries.
    Luego puedo definir su posición con setPosition.
    Puedo hacer todo en un paso y definir tamaño y posición con setBoundaries.
    Si durante el ciclo de vida del personaje (Sprite) quiero cambiar su tramaño, puedo setear nuevamente setBoundaries y lo cambio.
    Esto lo hice por ejemplo en EnemyOne, EnemyTwo, PowerBox, etc. cuando cambio su animación para que exploten.
    Lo anterior funciona bien si el sprite no fue rotado, sino es muy complejo setear bien el tamaño nuevamente ya que si está rotado
    el ancho a veces se convierte en altura y viceversa. De igual manera rota el vértice inferior izquierdo y la verdad resulta muy muy complejo
    determinar el nuevo sistema de coordenadas.
    Lo que hice en esos casos fue definir un nuevo sprite (en una variable), seteando su setBoundaries, que la dibujo finalmente sobre el sprite
    del personaje en el método draw (ver por ejemplo FinalEnemyLevelOne, los sprites powerFXSprite y explosionFXSprite). Esto lo hice así
    porque es imposible deducir el ancho y altura del sprite FinalEnemyLevelOne ya que este se pasa rotando por la pantalla.
--------------------------- code copy paste ---------------------------------------
para items los cast
para vidas heal

armas
https://mrbubblewand.wordpress.com/2010/12/30/animation-light_004/ yo
https://mrbubblewand.wordpress.com/2010/04/11/animation-light_003/ enemigo
https://mrbubblewand.wordpress.com/2010/01/29/animation-wind_002/
https://mrbubblewand.wordpress.com/2010/01/28/animation-magic_005/
https://mrbubblewand.wordpress.com/2010/01/18/animation-magic_004/
https://mrbubblewand.wordpress.com/2009/10/05/animation-fire_002/
https://mrbubblewand.wordpress.com/2009/09/13/animation-magic_003/
https://mrbubblewand.wordpress.com/2009/06/09/animation-effect_001/
https://mrbubblewand.wordpress.com/2009/06/07/animation-magic_02/
https://mrbubblewand.wordpress.com/2009/06/05/animations-thunder_01-heal_01-2/

candidatos a poderes del malo:
effect_001 tiene fondo negro
wind_003 queda bien
thunder_003 queda hermoso pero es cuadrado :(
heal_003 no queda muy lindo, no se destaca.
magic_008 no queda muy lindo, no se destaca.

posibles audios ante la perdida de poder
https://freesound.org/people/Streetpoptunez/sounds/413074/
https://freesound.org/people/KauaiBoyRK/sounds/59545/
https://freesound.org/people/OwlStorm/sounds/404767/
https://freesound.org/people/suntemple/sounds/253173/
https://freesound.org/people/Callum_Sharp279/sounds/200469/
https://freesound.org/people/Veiler/sounds/264462/ (bump)

posibles poderes
https://mrbubblewand.files.wordpress.com/2009/08/special_002.png
https://mrbubblewand.files.wordpress.com/2010/02/magic_006.png
https://mrbubblewand.files.wordpress.com/2010/01/magic_005.png
https://mrbubblewand.files.wordpress.com/2010/01/magic_004.png
https://mrbubblewand.files.wordpress.com/2009/09/magic_003.png
https://mrbubblewand.files.wordpress.com/2009/08/magic_002.png (fondo negro)
https://mrbubblewand.files.wordpress.com/2009/08/heal_001.png
https://mrbubblewand.files.wordpress.com/2009/08/darkness_001.png

posibles efectos para escudos
escudo
https://mrbubblewand.files.wordpress.com/2010/06/fire_003.png si
https://mrbubblewand.files.wordpress.com/2009/10/water_003.png puede ser
https://mrbubblewand.files.wordpress.com/2010/05/earth_002.png no
https://mrbubblewand.files.wordpress.com/2010/01/magic_004.png
https://mrbubblewand.files.wordpress.com/2010/02/magic_006.png puede ser

-----------------------------------------------------------------------------------
FUNCION SENO
  private float getNewX(float x, float y, float dt) {
        return (float) Math.sin(2.0f * y - dt) * Constants.V_WIDTH / Constants.PPM;
    }

    private Vector2 getNewVelocity(float yActual, float dt) {
        /*
        origen = (b2body.getPosition().x, 2body.getPosition().y)
        destino = (getNewX(b2body.getPosition().x, b2body.getPosition().y, dt), b2body.getPosition().y - dt)
        destino - origen = ()
         */
        velocity = new Vector2();
        velocity.x = getNewX(b2body.getPosition().x, b2body.getPosition().y, dt) - b2body.getPosition().x;
        velocity.y = dt;
        velocity.nor();
        velocity.x = velocity.x * 4.0f;
        velocity.y = -velocity.y * 4.0f;
        return velocity;
    }

	luego.....

	 private void stateAlive(float dt) {
        b2body.setLinearVelocity(getNewVelocity(b2body.getPosition().y, dt));

        /* Update our Sprite to correspond with the position of our Box2D body:
        * Set this Sprite's position on the lower left vertex of a Rectangle determined by its b2body to draw it correctly.
        * At this time, EnemyOne may have collided with sth. and therefore it has a new position after running the physical simulation.
        * In b2box the origin is at the center of the body, so we must recalculate the new lower left vertex of its bounds.
        * GetWidth and getHeight was established in the constructor of this class (see setBounds).
        * Once its position is established correctly, the Sprite can be drawn at the exact point it should be.
         */
        setPosition(b2body.getPosition().x - getWidth() / 2, b2body.getPosition().y - getHeight() / 2);
        setRegion((TextureRegion) enemyOneAnimation.getKeyFrame(stateTime, true));
        stateTime += dt;
        openFireTime += dt;
        if (openFireTime > Constants.ENEMYONE_FIRE_DELAY_SECONDS) {
