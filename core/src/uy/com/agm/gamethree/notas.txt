TILESET
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

PENDIENTES
----------
- definir mas objetos en mi nivel (blocks, coins)
- cuando este estable comentar todo el codigo
- ver si no tengo metodos overrited de mas
- usar el assetmanager, copiarlo del conejo haciendo una splash screen capaz.
- Definir clase constantes.
- resolver el tema de cuando el personaje se va de la pantalla, pero con velocidad. Porque asi como esta estoy
seguro que no detecta colisiones porque lo saco del mundo fisico. capaz que se puede pensar en algun objeto
invisible que vaya avanzando con la camara y listo. creo es lo mejor.
- en lugar de tolerancia, capaz que basta con limlitar su velocidad maxima.
- LIMITAR SI O SI SU VELOCIDAD MAXIMA CRC
- USAR LA CLASE BASE DE OBJETOS DEL CONEJO.

DUDAS
-----
- Que se ejecuta primero el update o el draw?
For instance, within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled by the distance traveled in time "delta" (it doesn't render them, just moves their position variables). Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta), which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.

VIDEO
-----
HACER REFACTORING Y COMENTAR UN POCO.
HACER CLASE ASSETS.
LUEGO:
EL LOCO LE LLAMA COIN A LOS BRICKS QUE SE ROMPEN, YO LE LLAME ITEM.
CREO QUE LO QUE DEBERIA HACER ES UN BRICK QUE SE ROMPE Y SUELTA UN ITEM QUE ME DA PODERES.
LO PUEDO IMPLEMENTAR IGUAL QUE EL Y ESO ARRANCA EN EL 21 TAL CUAL.
LUEGO DEBERIA ARREGLAR MI "COIN" PARA QUE SE COMPORTE COMO EL BRICK DE EL
(VIDEO 13: Obtiene una tile (brick) y la hace desaparecer cuando es golpeada.
No me sirve porque mis dibujos tienen tiles variables.)

Voy por el 21.
video 23 minuto 2.17 refactoring, pasa el tile en lugar del rectangulo.




HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames
- http://www.online-image-editor.com/: editor en linea

METODOLOGIA
-----------
1)
   Posicon + velocidad da posicion
   Para ir de A a B, debo restar los vectores B - A.
   La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

   Vector2 position = new Vector2();
   Vector2 velocity = new Vector2();
   Vector2 acceleration = new Vector2(0, -10);
   while(simulationRuns) {
   float deltaTime = getDeltaTime();
   velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
   position.add(velocity.x * deltaTime, velocity.y * deltaTime);
   }
   This is called numerical Euler integration, and it is the most intuitive of the integration methods
   used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
   of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
   movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
   loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
   then update the position, based on the velocity multiplied by the delta time. That’s all there is to
   the big, scary word integration.

2)
Personaje a partir de gif animado:
- Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
- Abrir cada imagen con Paint.net y ponerle fondo transparente.
- Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
- Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc.
- Usar el TexturePacker para unirlas todas.

Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
- Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
- Usar el TexturePacker para unirlas todas.

3)
Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
En las layers (tiled) pongo un rectangulo de cualquier tamano.
Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
Ese tamanio son pixels / (pixels / metro) o sea, metros.
Entonces no importaria el tamano del rectangulo en las layers.
hola 2 gika
