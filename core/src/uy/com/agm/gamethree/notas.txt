TILESET
-------
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

custom properties:
enemyBullet
powerOne
damage (int)

ALCANCE
-------
El level tiene puentes
Hay 2 tipos de bolas:
	1) bola de poder
		- nada, escudo, invisibilidad (por tiempo), detener pantalla (por tiempo), te pones rojo y chocas a todos (por tiempo),
		  invulnerabilidad (te rodea una burbuja) es por tiempo, matar a todos de una vez.
	2) bola de armas
		- nada, boomeran, triple bola de fuego, doble fecha, flecha simple (arma por defecto)
Bloques con sorpresas

enemigo1: bolas negras que bajan derecho
		  luego disparan
enemigo2: bandada murcielagos
		  luego disparan
		  luego vienen desfazados los murcielagos
enemigo3: caballeros que bajan derecho luego se mueven un poco a la derecha o la izquierda y luego bajan de nuevo y disparan
enemigo4: nubes (viajan tranqui como funcion seno y luego se te tiran arriba rapido)

PENDIENTES
----------
- subir todos mis proyectos a github
- debería morir cuando quedo aplastado entre el borde inferior y un arbol arriba.
- las properties del tilededitor pueden ser boolean, usarlas.
- tendria que agregar otra layer para los puentes porque por ej. las balas desaparecen al chocar con
bordes y objetos
- No me convence mucho que los personajes que esten por debajo de la camara sean setactive en false. Para mi deberian morir.
Con hero en particular, si lo destruyo pasa algo raro en donde aparece en la pantalla nuevamente con una bala en medio. Con setactive funciona bien.
- revisar de vuelta todo lo publico y documentar por que dejo cosas publicas.
- en todos los sprites, cuando mueren (estado DEAD o FINISHED o el que sea). En el case deberia removerlos de las colecciones del b2worldcreator
para que no jodan. Hoy en dia no joden porque el update tiene ese case y el draw tiene un if.
Para ello en b2worldcreator crear:
public void removeEnemy(Enemy enemy) {
enemies.removeValue(enemy, true);
}
(observacion: la eliminacion deberia ser inmediatamente que destruyo su b2body pero creo que
eso coincide exactamente con el seteo del estado DEAD, asi que queda prolijo hacerlo en la siguiente
vuelta cuando se evalua el estado dead en el upadte)

IDEAS
-----
- Cuando explota un enemigo puedo hacer aparecer 2 enemigos
- Cuando le disparo a un enemigo, no explota sino que se queda quieto (o se congela con efecto) y luego revive.
- Para evitar el disparo sin querer, programar un circulo en donde hacer touch para disparar.

TENGO LAS SIGUIENTES CUSTOM PROPERTIES
--------------------------------------
powerOne
enemyBullet
strength 3

DUDAS
-----
- Que se ejecuta primero el update o el draw?
For instance, within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled by the distance
traveled in time "delta" (it doesn't render them, just moves their position variables).
Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta),
which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.
- git:
    traer un solo fuente (con sourcetree)
    ver diferencias de mi fuente actual con el del repositorio
    abrir un git local (un proyecto) sin tener que hacer clone
    No me quedo un acceso directo, sino que ejecuto el exe que baje
- NO SE DONDE TENGO QUE HACER ASSET.DISPOSE, lo puse en gamethree


VIDEO
-----
FELICITACIONES
VER CONTROLADOR

HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames
- http://www.online-image-editor.com/: editor en linea
- sourceTree para administrar git
- https://audio.online-convert.com/es/convertir-a-ogg: conversor de mp3 a ogg
- https://github.com/BrentAureli/SuperMario / https://www.patreon.com/BrentAureli

METODOLOGIA
-----------
1)
    Posicon + velocidad da posicion
    Para ir de A a B, debo restar los vectores B - A.
    La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

    Vector2 position = new Vector2();
    Vector2 velocity = new Vector2();
    Vector2 acceleration = new Vector2(0, -10);
    while(simulationRuns) {
        float deltaTime = getDeltaTime();
        velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
    }
    This is called numerical Euler integration, and it is the most intuitive of the integration methods
    used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
    of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
    movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
    loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
    then update the position, based on the velocity multiplied by the delta time. That’s all there is to
    the big, scary word integration.

2)
    Personaje a partir de gif animado:
    - Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
    - Abrir cada imagen con Paint.net y ponerle fondo transparente.
    - Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
    - Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc.
    - Usar el TexturePacker para unirlas todas.

    Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
    - Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
    - Usar el TexturePacker para unirlas todas.

3)
    Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
    En las layers (tiled) pongo un rectangulo de cualquier tamano.
    Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
    Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
    Ese tamanio son pixels / (pixels / metro) o sea, metros.
    Entonces no importaria el tamano del rectangulo en las layers.

6)
    SISTEMA DE COORDENADAS
    ----------------------
    SPRITE:
    setPosition(x,y) indica el vertice inferior izquierdo de un rectangulo definido con setBounds.
    setBounds(x, y, width, hegiht) indica un rectangulo cuyo vertice inferior izquierdo esta en x, y.
    Siempre debo trabajar con coordenadas del mundo (no pixels).
    En otras palabras, el origen de coordenadas esta en su vertice inferior izquierdo.

    CAMARA:
    La camara tiene como origen de coordenadas su centro, es decir, el centro de la pantalla es (cam.x, cam.y).

    BOX2D
    Los objetos de box2d (b2body) tienen como origen de coordenadas su centro.
    Es decir su centro es (b2body.getPosition().x, b2body.getPosition().y).

    MUNDO
    Su origen de coordenadas esta en su esquina inferior izquierda.
    Identico a SPRITE.

    TOUCH EVENTOS
    Su origen está en la esquina superior izquierda (lpmqtp)
    Es decir, el (0, 0) esta arriba a la izquierda.

    TEXTURAS
    Tienen un u y v. No recuerdo exactamente. Es otro caso distinto.

7)
    Para levantar proyecto github:
    - instalar java 8 y definir JAVA_HOME
    - instalar android sdk y definir ANDROID_HOME (pues la usa git)
    - instalar git y agregarlo al PATH. Definir su proxy:
    git config --global http.proxy http://amorales:tqspy.7719@proxy.bse.com.uy:8080
    - instalar maven y agregarlo al PATH
    - instalar android studio y en settings apuntar a la instalación de git. Definir su proxy, puse el del bse.
    - abrir android studio, open new project y seleccionar la carpeta androidStudioProjects.
    - luego checkout (vcs/checkout from version control) desde github: https://github.com/agmCorp/GameThree (https://github.com/BrentAureli/SuperMario)
    - cerrar andoid studio
    /* esto podría no ser necesario
    - ir a dos, dentro de gamethree:
    gradlew -Dhttp.proxyHost=proxy.bse.com.uy -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.bse.com.uy -Dhttps.proxyPort=8080 build
    Si es para supermario, puede ser que me falte alguna cosa de android, ahí tengo que abrir el sdk manager y bajarla.
    */
    - abrir andoid studio, darle luego open y seleccionar el archivo build.grandle, ahí pide proxy meter el del bse.
    - en settings deshabilitar configuration on demand
    - luego view/windows tools/gradle
    - luego dalre sincronizar, esperar que finalice  la indexacion
    Si le falta alguna librería de andoid, en el error da un link en donde pinchás y te la instala en c\users\amorales\appdata\local\android\sdk.
    Sino el sdk Manager está en el menú tools/Android y ahí las cargo yo a mano hasta resolver todos los problemas.
    Tuve que editar el build.grandle de super mario y poner com.android.tools.build:gradle:2.3.0 en lugar de com.android.tools.build:gradle:2.3.0-beta1
    - cerrar el android studio, abrir el proyecto, crear el run deskotp, luego darle run y pide module, ponerle desktop.
    - la pc de mi trabajo no soporta opengl2.0 así que solo puedo ejecutar en android.

8)
   git fetch origin
   git reset --hard origin/master

   Puedo hacer un git pull, pero capaz lo mejor es hacer:
   git fetch // trae cambios pero no los aplica
   git diff // me muestra los cambios
   git merge // ejecuta cambios

   usar Sourcetree: Reset current branch to this commit
   Con eso hago un update forzado sobreescribiendo el local con el remoto.

9)
    Para generar el jar y correrlo en pc, dentro del proyecto ejecutar:
    gradlew desktop:dist

    El jar queda en GameThree\desktop\build\libs
--------------------------- code copy paste ---------------------------------------
Se pone en modo fantasta y queda todo igual excepto que los monstruos si lo tocan no le hacen nada
// ************* inicio
        // Apply Skin Color
        float alpha = 0.7f;
        batch.setColor(1, 1, 1, alpha);


        Filter filter = new Filter();
        filter.categoryBits = GameThree.HERO_BIT;
        filter.maskBits =  GameThree.DEFAULT_BIT |
                GameThree.COINBOX_BIT |
                GameThree.OBSTACLE_BIT |
                GameThree.ITEM_BIT;
        b2body.getFixtureList().get(0).setFilterData(filter);
// ************** fin
        // Draws a rectangle with the texture coordinates rotated 90 degrees.
        batch.draw(this, this.b2body.getPosition().x - width / 2, this.b2body.getPosition().y - height / 2,
                width / 2, height / 2, width, height, 1.0f, 1.0f, angulo, clockwise);
// ************** inicio
// Reset color to white
        batch.setColor(1, 1, 1, 1);
// **************   fin

 public void draw(SpriteBatch batch) {
        // estado normal
        // esto es asi para compensar lo que hace el draw por defecto, que dibuja rotado no se por que.
        //clockwise - If true, the texture coordinates are rotated 90 degrees clockwise. If false, they are rotated 90 degrees counter clockwise.
        boolean clockwise = true;
        float angulo = 90;
        float height = this.getWidth(); // si multiplico ambos por 0.8f es el 80% del sprite del archivo .png
        float width = this.getHeight();
        float temp;

        // touch
        float vAngle = this.b2body.getLinearVelocity().angle();

// anda bien
        if (0 < vAngle && vAngle <= 90) {
            Gdx.app.debug(TAG, "VANGLE " + vAngle);
            angulo = vAngle;
            //angulo = 45;
        }

        if (90 < vAngle && vAngle <= 180) {
            Gdx.app.debug(TAG, "VANGLE " + vAngle);
            angulo = 270.0f - vAngle;
            //angulo = 135;
        }

        if (180 < vAngle && vAngle <= 270) {
            Gdx.app.debug(TAG, "VANGLE " + vAngle);
            angulo = vAngle;
            //angulo = 225;
            clockwise = false;
        }

        if (270 < vAngle && vAngle <= 360) {
            Gdx.app.debug(TAG, "VANGLE " + vAngle);
            angulo = vAngle;
            //angulo = 315;
            clockwise = false;
        }

        // Draws a rectangle with the texture coordinates rotated 90 degrees.
        /*
        batch.draw(this, this.b2body.getPosition().x - width / 2, this.b2body.getPosition().y - height / 2,
                width / 2, height / 2, width, height, 1.0f, 1.0f, angulo, clockwise);
                */
    }


            /* NO TOCAR
            Vector2 delta = new Vector2(deltaX / Constants.PPM, deltaY / Constants.PPM);

            if (delta.len() > Constants.HERO_LEN_SPEED / Constants.PPM) {
                game.playScreen.player.b2body.setLinearVelocity(deltaX * Constants.HERO_WEIGHTING_SPEED, -deltaY * Constants.HERO_WEIGHTING_SPEED);
            } else {
                game.playScreen.player.b2body.setLinearVelocity(0, 0);
            }
            */
para items los cast
para vidas heal

armas
https://mrbubblewand.wordpress.com/2010/12/30/animation-light_004/ yo
https://mrbubblewand.wordpress.com/2010/04/11/animation-light_003/ enemigo
https://mrbubblewand.wordpress.com/2010/01/29/animation-wind_002/
https://mrbubblewand.wordpress.com/2010/01/28/animation-magic_005/
https://mrbubblewand.wordpress.com/2010/01/18/animation-magic_004/
https://mrbubblewand.wordpress.com/2009/10/05/animation-fire_002/
https://mrbubblewand.wordpress.com/2009/09/13/animation-magic_003/
https://mrbubblewand.wordpress.com/2009/06/09/animation-effect_001/
https://mrbubblewand.wordpress.com/2009/06/07/animation-magic_02/
https://mrbubblewand.wordpress.com/2009/06/05/animations-thunder_01-heal_01-2/
