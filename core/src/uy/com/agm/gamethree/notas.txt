TILESET
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

PENDIENTES
----------
- definir mas objetos en mi nivel (blocks, coins)
- cuando este estable comentar todo el codigo
- ver si no tengo metodos overrited de mas
- usar el assetmanager, copiarlo del conejo haciendo una splash screen capaz.
- Definir clase constantes.
- resolver el tema de cuando el personaje se va de la pantalla, pero con velocidad. Porque asi como esta estoy
seguro que no detecta colisiones porque lo saco del mundo fisico. capaz que se puede pensar en algun objeto
invisible que vaya avanzando con la camara y listo. creo es lo mejor.
- en lugar de tolerancia, capaz que basta con limlitar su velocidad maxima.
- LIMITAR SI O SI SU VELOCIDAD MAXIMA CRC
- USAR LA CLASE BASE DE OBJETOS DEL CONEJO.

DUDAS
-----
- Que se ejecuta primero el update o el draw?
For instance, within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled by the distance
traveled in time "delta" (it doesn't render them, just moves their position variables).
Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta),
which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.

VIDEO
-----
HACER REFACTORING Y COMENTAR UN POCO.
LUEGO:
EL LOCO LE LLAMA COIN A LOS BRICKS QUE SE ROMPEN, YO LE LLAME ITEM.
CREO QUE LO QUE DEBERIA HACER ES UN BRICK QUE SE ROMPE Y SUELTA UN ITEM QUE ME DA PODERES.
LO PUEDO IMPLEMENTAR IGUAL QUE EL Y ESO ARRANCA EN EL 21 TAL CUAL.
LUEGO DEBERIA ARREGLAR MI "COIN" PARA QUE SE COMPORTE COMO EL BRICK DE EL
(VIDEO 13: Obtiene una tile (brick) y la hace desaparecer cuando es golpeada.
No me sirve porque mis dibujos tienen tiles variables.)

Voy por el 23.
video 23 minuto 2.17 refactoring, pasa el tile en lugar del rectangulo.

- revisar lo que hice, renombrar el spawn (engendrar).
buscar un brick de asset y buscar un premio.
SE CAE CUANDO HAY MULTIPLES REGALOS ABIERTOS, COMO QUE COMPARTEN ALGO..SE AFECTA EL MOVIMIENTO...VERLO...DEBE SER FACIL.

HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames
- http://www.online-image-editor.com/: editor en linea

METODOLOGIA
-----------
1)
   Posicon + velocidad da posicion
   Para ir de A a B, debo restar los vectores B - A.
   La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

   Vector2 position = new Vector2();
   Vector2 velocity = new Vector2();
   Vector2 acceleration = new Vector2(0, -10);
   while(simulationRuns) {
   float deltaTime = getDeltaTime();
   velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
   position.add(velocity.x * deltaTime, velocity.y * deltaTime);
   }
   This is called numerical Euler integration, and it is the most intuitive of the integration methods
   used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
   of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
   movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
   loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
   then update the position, based on the velocity multiplied by the delta time. That’s all there is to
   the big, scary word integration.

2)
Personaje a partir de gif animado:
- Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
- Abrir cada imagen con Paint.net y ponerle fondo transparente.
- Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
- Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc.
- Usar el TexturePacker para unirlas todas.

Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
- Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
- Usar el TexturePacker para unirlas todas.

3)
Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
En las layers (tiled) pongo un rectangulo de cualquier tamano.
Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
Ese tamanio son pixels / (pixels / metro) o sea, metros.
Entonces no importaria el tamano del rectangulo en las layers.

5)
Para traerme las cosas de github que modifiqué en el trabajo, hacer pull.

6)
PERSONAJE: position(x,y) indica su centro
MUNDO (10 metros de ancho por 15 metros de largo): su origen está en la esquina inferior izquierda
TOUCH EVENTOS: su origen está en la esquina superior izquierda

7)
Para levantar en el trabajo:
- instalar java 8 y definir JAVA_HOME
- instalar android sdk y definir ANDROID_HOME (pues la usa git)
- instalar git y agregarlo al PATH. Definir su proxy:
git config --global http.proxy http://amorales:tqspy.7719@proxy.bse.com.uy:8080
- instalar maven y agregarlo al PATH
- instalar android studio y en settings apuntar a la instalación de git. Definir su proxy, puse el del bse.
- abrir android studio, open new project y seleccionar la carpeta androidStudioProjects.
- luego checkout (vcs/checkout from version control) desde github: https://github.com/agmCorp/GameThree (https://github.com/BrentAureli/SuperMario)
- cerrar andoid studio
/* esto podría no ser necesario
- ir a dos, dentro de gamethree:
gradlew -Dhttp.proxyHost=proxy.bse.com.uy -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.bse.com.uy -Dhttps.proxyPort=8080 build
Si es para supermario, puede ser que me falte alguna cosa de android, ahí tengo que abrir el sdk manager y bajarla.
*/
- abrir andoid studio, darle luego open y seleccionar el archivo build.grandle, ahí pide proxy meter el del bse.
- en settings deshabilitar configuration on demand
- luego view/windows tools/gradle
- luego dalre sincronizar, esperar que finalice  la indexacion
Si le falta alguna librería de andoid, en el error da un link en donde pinchás y te la instala en c\users\amorales\appdata\local\android\sdk.
Sino el sdk Manager está en el menú tools/Android y ahí las cargo yo a mano hasta resolver todos los problemas.
Tuve que editar el build.grandle de super mario y poner com.android.tools.build:gradle:2.3.0 en lugar de com.android.tools.build:gradle:2.3.0-beta1
- cerrar el android studio, abrir el proyecto, crear el run deskotp, luego darle run y pide module, ponerle desktop.
- la pc de mi trabajo no soporta opengl2.0 así que solo puedo ejecutar en android.

8)
   git fetch origin
   git reset --hard origin/master

   Puedo hacer un git pull, pero capaz lo mejor es hacer:
   git fetch // trae cambios pero no los aplica
   git diff // me muestra los cambios
   git merge // ejecuta cambios

********************************************
no entiendo git:
En fuente A.java escribo hola
Hago commit y hago push a github
En fuente A.java borro el hola y pongo chau
hago commit
En fuente A.java borro el chau y pongo zapato.
hago commit
Ahora me arrepentí de todo y quiero lo que está en github (o sea que el fuente A.java me lo sobreescriba con lo que haya en github)

Hay 2 casos: Alguien tocó también ese fuente y los subió a github, en cuyo caso hago un pull y me lo traigo?
Nadie tocó ese fuente y por ende yo fui el último que lo subió a github, no se como traerlo (checkout?)
ADEMAS QUIERO HACER ESTO PARA TODAS LAS DIFERENCIAS DEL PROYECTO, O SEA, QUIERO REFRESCARLO CON LO ULTIMO DE GITHUB
