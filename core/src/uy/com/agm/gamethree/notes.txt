HACER PRIORIDAD 1
-----------------
- TERMINAR EL NIVEL 3
- incluir highscores. En la pantalla de level completed si hubo highscore se indica.
- Hacer pantallas de credit, help
agregar credits con cuenta bancaria para donación, algo asi:
support this game:
(icono corazón) Support the developer by paying above the minimum price
+$1.00 +$2.00 +$5.00 +$10.00
Pay with paypal, pay with card bitcoin
Agregar en agredecimientos a Juan LLopart
- la pantalla de level completed debe tener los clasicos botones de las estrellitas, el score y high, etc.
- Poder aabb que los deja quietos:
IMPLEMENTACION:
Cada enemigo deberia tener un metodo freeze() y asegurarme que no disparen y ta.
Capaz que hasta queda lindo que mueran con 1 disparo, pero sino no.
Si esta "freeze" llamo al onDestroy().
Capaz lo que puedo hacer ademas, es usar internamente este metodo para evitar que los bichos sigan
moviendose cuando estoy dyingup/down...que retomen el movimiento cuando volvi a jugar.

HACER PRIORIDAD 2
-----------------
- agregar transitions
SEGUN MI ANALISIS PARA INCLUIR TRANSITIONS:
Mi clase GameThree es la análoga a DirectedGame.
Entonces en mi GameThree debo definir las funciones y cosas que tiene DirectedGame.
Una vez hecho eso, en el screenManager puedo usar la nueva funcion setScreen que recibe una transición.
- poner una intro y una historia. Copiar la historia del juego de knightmare remake! :D
- hacer un mapa de los niveles
- Seguir viendo las mejoras del video (como slow motion) https://www.youtube.com/watch?v=AJdEqssNZ-U. Si en mi juego
pongo las explosiones enormes (resizeFactor = 10 por ejemplo) queda un lindo efecto que abarca toda
la pantalla

HACER PRIORIDAD 3
-----------------
- Creo que showRedFlash debería estar en dimScreen. Hay que ver si su help también.
El problema es que si hay un help no modal en pantalla y se me escapa un enemigo, la redscreen cierra ese help para mostrarse.
- poner una pausa al morir, para que se vea bien el impacto o camara lenta.
No queda bien en el caso de recibir balas muy grandes en donde los sprites no hacen contacto (pero si las box2d).
En ese caso el jugador no entenderia por que muere porque los dibujos no se tocan.
Pero capaz se podria poner al morir aplastado. Podria ademas poner un audio de aplastamiento y hasta capaz una animacion o
parpadeo antes de dyingup.
- Deberia hacer una clase KinematicBackgroundObject analoga a StaticBackgroundObject y heredar de ella en Edge y en Bridge. Intenté una
vez y me resultó complicado. Tambien deberia hacer una interfaz llamada GameObject que tenga metodos generales a TODOS mis objetos del juego.
Candidatos whoami, getcurrentstate, getboundingmeters...pero hay que estudiarlo.
Esa interfaz la puedo usar ademas dentro de ActorDef.
- poner particulas parece facil, capaz lluvia.
- poner alguna animacion linda de hero cuando mata al enemigo final y gana el nivel.
Si hero le gana al boss, puedo poner al final del hero.update(): if boss is dead, then currentstate = dancing.
Y en el update si el estado es dancing, hacer una animacion graciosa.
Si pongo pausa en el juego podría poder alguna animación graciosa de Hero...creo que basta con hacerle a hero un método drawEspecial() que haga la animacion
y llamarlo desde el método renderGame() si estoy en pausa..pero no se
- Ver si puedo reducir el tamano de la musica (sonido no ocupa nada).
- Ver si en los metodos criticos de update y draw (render) no estoy haciendo muchos new.
- Los tiempos y cantidad de imagenes en las clases Assetxx no estan en constantes, creo no interesa.
- Un poder de disparo puede variar:
    dibujo y tamano de la bala (sprite y b2body) --- contemplado en la estrategia
    cantidad, --- contemplado en la estrategia
    delay, --- contemplado en la estrategia
    animacion, --- contemplado en la estrategia
    tipo de movimiento (boomerang):
        se me ocurre modelarlo solo con un enumerado recibido en el constructor de heroBullet o EnemyBullet
        y luego en el stateShoot de HeroBullet o EnemyBullet. Aunque lo más prolijo que se me ocurre sería
        definir una clase nueva FancyBullet que herede de Weapon y tenga toda su lógica loca adentro (como la tiene HeroBullet o EnemyBullet).
        Luego el B2WorldCreator la contemplaría.
    velocidad --- contemplado en la estrategia
    sonido --- contemplado en la estrategia

SOLO IDEAS
----------
- hacer una bala grandota y ruidosa con shake capaz
- Estadisticas: contar los disparos y contar los muertos, hacer porcentaje de efectividad y mostar en level completed.
Esto lo tengo que contabilizar a medida que voy matando y NO al final viendo los arreglos (porque yo liquido los enemigos restantes o
los que se van de la pantalla).
Puedo relacionarlo con la otra idea del contador de bichos que se me escapan.
- Para nivel 4 hacer un puente que rote con las junturas esas de motor
- Animación o ruido distinto al ser aplastado.
- enemigos:
    - hay que dispararle mucho para matarlo.
    - el enemigo final puede estar acompanado de otros simples, ojo con el metodo Enemy.terminate().
    - se mueva en 8 horizontal y dispare abanico de balas como mi poder fire.
    - enemigofinal que me sigue
    - enemigofinal son varios ojos (circulos box2d) que cambian de color y en un estado disparan. Se mueven juntos y están
      rodeados por una gran textura que es el enemigo!
    - luego de un rato hace blink y desaparece y vuelve a aparecer. Disparando siempre.
    - enemigo que al recibir disparo se parte en 2 y luego de un rato se vuelve a juntar (como el enemyfour pero
    se parte y hay que no tocar esas partes).
    - enemigo que viene vertical hacia abajo y cuando llega a la linea media de la pantalla, determina (en ese
    instante) en donde esta el hero y va hacia ahi.
    - enemigo que es como una estella (cometa). Para ese efecto agregar varias veces el sprite con distinto alpha.
    Se mueve rapido derecho en diagonal.
- se puede hacer un arma para enemigo final que vaya medio boomerang o en circulos, para ello debería crear otra
EnemyBullet (BoomerangBullet) que contemple el movimiento y una strategy nueva que cree el objeto pasando BoomerangBullet para que el
b2worldcreator lo cree.
- minuto 33.43 puentes dinámicos
- para la version escritorio creo me conviene usar heroLeft y heroRight porque tengo las animaciones y es facil incluirlas.
Con el enemigo final 2 no se...no logro visualizar esos cambios en perspectiva.
- Frases:
    - Humans are the real monsters
    - La que anoté por ahí en el papel: You were the monster all along
- Nombre para niveles:
    the forest

DUDAS Y BUGS
------------
- El back si lo dejo apretado hace ruido.
- No se donde tengo que hacer Assets.dispose(), lo puse en gamethree
- Manejo de memoria y uso de Vector2 y uso de Labels en las pantallas.
El vector2 no tiene dispose, las labels tampoco...
- Queda el bug de que si reproducis un sonido y luego cambias de aplicacion, al volver (el juego esta en pausa) reproduce
el resto del sonido. No lo supe arreglar...
- A veces los sonidos no se reproducen
- Quisiera la opinion de alguien que sepa sobre si es mejor usar box2d para detectar colisiones (y luchar con los
movimientos no pudiendo cambiar la posición) o es mejor usar overlaps (donde capaz tengo que hacer miles de combinaciones
de cruzamientos). Capaz le puedo preguntar al loco de linkedin. Hay algún otro enfoque?
- Una vez se me quedó la araña trabada en la esquina superior izquierda, luego de haber jugado todo el nivel normal.
Intenté reproducirlo teletransportandome y dejando la araña jugar sola por varios minutos y no lo logré.
Intenté reproducirlo teletransportandome y muriendo aplastado antes de entrar a la epic fight y tampoco.

TENGO
-----
- borders, edges, paths, obstacles, powerboxes, enemies, finals, items, weapons
- enemigos comunes 11 (uso 3 o 4 enemigos por nivel):
one - amarillo
two - murcielago
three - bola negra
four - congelados
five - dragon en circulos
six - rayo
seven - se multiplica
eight - bicho verde cometa
nine - fenix
ten - 2 circulos
eleven - hombres de piedra
twelve - vampirito violeta
- enemigos finales: 3
- poderes 5 -3 de habilidad, 2 de fuego- (2 poderes por nivel)
- 1 moneda x 3
- 1 shuriken
- 1 item vidas
- 1 your soul is mine

ESTIMACION
----------
En youtube el knight se desplaza 10 pixels por segundo aprox.
El primer nivel dura 5 minutos (300 segundos).
En youtube el knight tiene 260 pixels de alto.
Entonces el nivel total mide 260 (primer pantalla) + 10 pixels * 300s = 3260.

O sea, son en total: 3260 / 260 = 12.5 pantallas, redondeo a 13.

Velocidad:
Se mueve a un 3.8% de pantalla por segundo.
En mi juego seria 3.8 de 800 por segundo, o sea, 30.4 pixels por segundo.

RESUMEN
En mi juego seria 0.304 la velocidad.
En mi juego serian 13 pantallas

Yo igual hice 10 pantallas, 13 me parece mucho porque me cuesta llenarlas de enemigos.

TILESET
-------
map 32x32 sin margin ni spacing
15 tiles de ancho (480/32 = 15)
250 de alto (10 pantallas, cada una de 25 tiles, 25 x 32 = 800 = viewportheight)
Mi mundo ancho 480, alto 800
mis texturas miden 1024 x 1024

CUSTOM PROPERTIES
-----------------
powerOne (int): ghost mode, indica el tiempo de uso
powerTwo (int): escudo, indica el tiempo de uso
powerThree (int): cambia el poder de disparo, indica el tiempo de uso
powerFour (int): thogh mode, indica el tiempo de uso
colOne (string): moneda
colSilverBullet (string): shuriken

strength (int): dureza de la powerbox
timesItFreeze (int): indica cuantas veces se puede congelar el enemyFour.
enemyBullet (string): indica si el enemigo dispara

HERRAMIENTAS
------------
- TiledEditor: para crear el nivel
- TexturePacker: para crear los assets de personajes y empacar las animaciones
- ShoeBox: para agarrar una imagen grande con muchos sprites y separar cada sprite en un archivo distinto numerado.
- https://ezgif.com/split: me permite separar un gif animado en frames (también permite convertir video en gif)
- http://www.online-image-editor.com/: editor en linea
- sourceTree para administrar git
- https://audio.online-convert.com/es/convertir-a-ogg: conversor de mp3 a ogg
- https://github.com/BrentAureli/SuperMario / https://www.patreon.com/BrentAureli
- https://freesound.org, user aclaveri/2es...etc. Para sonido.
- https://www.youtube.com/watch?v=dxPf1M7YORU&feature=youtu.be para crear fonts ver ese video
- https://www.imgonline.com.ua/eng/cut-photo-into-pieces.php para cortar una imagen en pedazos iguales
- pngcrush para reducir el tamano de los .png (https://pmt.sourceforge.io/pngcrush/)
https://developer.android.com/topic/performance/reduce-apk-size.html
- https://cloudconvert.com/svg-to-png: svg to png converter
- https://bulkresizephotos.com: para redimensionar imagenes batch
- Tiny png api key 7yaS9nq0e-PmOCid1k6me6gk_bjTamPq (para usar en Texture Packer)
También lo puedo usar directo en https://tinypng.com/ para imágenes menores a 5 megas.
Para imágenes más pesadas usar curl. Ver "lecciones aprendidas 24".
- http://flamingtext.com/logo/Design-Cartoon Para crear fonts bonitas

LECCIONES APRENDIDAS
--------------------
1)
    Posicon + velocidad da posicion
    Para ir de A a B, debo restar los vectores B - A.
    La diferencia entre la posicion actual y la posicion futura es la VELOCIDAD (VECTOR VELOCIDAD).

    Vector2 position = new Vector2();
    Vector2 velocity = new Vector2();
    Vector2 acceleration = new Vector2(0, -10);
    while(simulationRuns) {
        float deltaTime = getDeltaTime();
        velocity.add(acceleration.x * deltaTime, acceleration.y * deltaTime);
        position.add(velocity.x * deltaTime, velocity.y * deltaTime);
    }
    This is called numerical Euler integration, and it is the most intuitive of the integration methods
    used in games. We start off with a position at (0,0), a velocity given as (0,0), and an acceleration
    of (0,–10), which means that the velocity will increase by 1 m/s on the y axis. There will be no
    movement on the x axis. Before we enter the integration loop, our object is standing still. Within the
    loop, we first update the velocity, based on the acceleration multiplied by the delta time, and
    then update the position, based on the velocity multiplied by the delta time. That’s all there is to
    the big, scary word integration.

2)
    Personaje a partir de gif animado:
    - Agarrar un gif animado y separarlo en frames con https://ezgif.com/split.
    - Abrir cada imagen con Paint.net y ponerle fondo transparente.
    - Abrir cada imagen con ShoeBox, y con la funcionalidad "Extract Sprites" extraer el dibujo quitando asi fondo innecesario.
    - Renombrar cada imagen como una secuencia: img_01.png, img_02.png, etc.
    - Usar el TexturePacker para unirlas todas.

    Personaje a partir de un gran archivo en donde estan las imagenes todas juntas:
    - Abrir la imagen con ShoeBox y usar la funcionalidad "Extract Sprites".
    - Usar el TexturePacker para unirlas todas.

3)
    Manejo de memoria: https://github.com/libgdx/libgdx/wiki/Memory-management

4)
    En las layers (tiled) pongo un rectangulo de cualquier tamano.
    Eso me da las coordenadas x, y en donde va a estar el enemigo, que son las del vertice inferior izquierdo.
    Luego cuando se crea el enemigo, el setbounds usa el tamano de la textura / PPM para definir el tamano.
    Ese tamanio son pixels / (pixels / metro) o sea, metros.
    Entonces no importaria el tamano del rectangulo en las layers.

6)
    SISTEMA DE COORDENADAS
    ----------------------
    SPRITE:
    setPosition(x,y) indica el vertice inferior izquierdo de un rectangulo definido con setBounds.
    setBounds(x, y, width, hegiht) indica un rectangulo cuyo vertice inferior izquierdo esta en x, y.
    Siempre debo trabajar con coordenadas del mundo (no pixels).
    En otras palabras, el origen de coordenadas esta en su vertice inferior izquierdo.

    CAMARA:
    (cam.x, cam.y) es el punto central de la "pantalla".
    El origen (0, 0) está en el vértice inferior izquierdo.

    BOX2D
    Los objetos de box2d (b2body) tienen como origen de coordenadas su centro.
    Es decir su centro es (b2body.getPosition().x, b2body.getPosition().y).

    MUNDO
    Su origen de coordenadas esta en su esquina inferior izquierda.
    Identico a SPRITE.

    TOUCH EVENTOS
    Su origen está en la esquina superior izquierda (lpmqtp)
    Es decir, el (0, 0) esta arriba a la izquierda.

    TEXTURAS
    Tienen un u y v. No recuerdo exactamente. Es otro caso distinto.

7)
    Para levantar proyecto github:
    - instalar java 8 y definir JAVA_HOME
    - instalar android sdk y definir ANDROID_HOME (pues la usa git)
    - instalar git y agregarlo al PATH. Definir su proxy:
    git config --global http.proxy http://amorales:tqspy.7719@proxy.bse.com.uy:8080
    - instalar maven y agregarlo al PATH
    - instalar android studio y en settings apuntar a la instalación de git. Definir su proxy, puse el del bse.
    - abrir android studio, open new project y seleccionar la carpeta androidStudioProjects.
    - luego checkout (vcs/checkout from version control) desde github: https://github.com/agmCorp/GameThree (https://github.com/BrentAureli/SuperMario)
    - cerrar andoid studio
    /* esto podría no ser necesario
    - ir a dos, dentro de gamethree:
    gradlew -Dhttp.proxyHost=proxy.bse.com.uy -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.bse.com.uy -Dhttps.proxyPort=8080 build
    Si es para supermario, puede ser que me falte alguna cosa de android, ahí tengo que abrir el sdk manager y bajarla.
    */
    - abrir andoid studio, darle luego open y seleccionar el archivo build.grandle, ahí pide proxy meter el del bse.
    - en settings deshabilitar configuration on demand
    - luego view/windows tools/gradle
    - luego dalre sincronizar, esperar que finalice  la indexacion
    Si le falta alguna librería de andoid, en el error da un link en donde pinchás y te la instala en shootStrategy\users\amorales\appdata\local\android\sdk.
    Sino el sdk Manager está en el menú tools/Android y ahí las cargo yo a mano hasta resolver todos los problemas.
    Tuve que editar el build.grandle de super mario y poner com.android.tools.build:gradle:2.3.0 en lugar de com.android.tools.build:gradle:2.3.0-beta1
    - cerrar el android studio, abrir el proyecto, crear el run deskotp, luego darle run y pide module, ponerle desktop.
    - la pc de mi trabajo no soporta opengl2.0 así que solo puedo ejecutar en android.

8)
   git fetch origin
   git reset --hard origin/master

   Puedo hacer un git pull, pero capaz lo mejor es hacer:
   git fetch // trae cambios pero no los aplica
   git diff // me muestra los cambios
   git merge // ejecuta cambios

   usar Sourcetree: Reset current branch to this commit
   Con eso hago un update forzado sobreescribiendo el local con el remoto.

9)
    Para generar el jar y correrlo en pc, dentro del proyecto ejecutar:
    gradlew desktop:dist

    El jar queda en GameThree\desktop\build\libs

    Aca explican como generar cada cosa:
    https://github.com/libgdx/libgdx/wiki/Gradle-on-the-Commandline

10)
    Para generar un BitmapFont usar SoeBox.
    Abrirlo y apretar "Bitmap Font". Eso copia al portapapeles un conjunto de letras.
    Abrir un editor grafico, seleccionar la herramienta para insertar texto y darle pegar.
    Eso pega todos los caracteres en pantalla, luego los edito como quiera cambiando colores, etc.
    Finalmente al png resultante, lo tiro nuevamente en la herramienta sobre "Bitmap Font", eso detecta
    los caracteres.
    Luego, para evitar tener que editar las settings a mano, debo apretar el boton "Auto fit Settings". Eso setea
    las propiedades de alto y ancho de cada letra para que se vea bien.
    Al salvar genera 2 archivos los cuales uso. Capaz que tengo que editarlos para cambiar una ruta absoluta que
    aparece alli (como en TiledEditor).

11)
    Para definir el tamaño (ancho y altura) de un sprite, debo usar setBoundaries.
    Luego puedo definir su posición con setPosition.
    Puedo hacer todo en un paso y definir tamaño y posición con setBoundaries.
    Si durante el ciclo de vida del personaje (Sprite) quiero cambiar su tramaño, puedo setear nuevamente setBoundaries y lo cambio.
    Esto lo hice por ejemplo en EnemyOne, EnemyTwo, PowerBox, etc. cuando cambio su animación para que exploten.
    Lo anterior funciona bien si el sprite no fue rotado, sino es muy complejo setear bien el tamaño nuevamente ya que si está rotado
    el ancho a veces se convierte en altura y viceversa. De igual manera rota el vértice inferior izquierdo y la verdad resulta muy muy complejo
    determinar el nuevo sistema de coordenadas.
    Lo que hice en esos casos fue definir un nuevo sprite (en una variable), seteando su setBoundaries, que la dibujo finalmente sobre el sprite
    del personaje en el método draw (ver por ejemplo FinalEnemyLevelOne, los sprites powerFXSprite y explosionFXSprite). Esto lo hice así
    porque es imposible deducir el ancho y altura del sprite FinalEnemyLevelOne ya que este se pasa rotando por la pantalla.

12)
   There are also the following methods that alter the bounding rectangle of a sprite (modifies the sprite's vertices):
   getBoundingRectangle(): recalculate vertices (see source code)
   setX(x)
   setY(y)
   setBounds(x,y,width,height)
   setSize(width,height)
   translate(diffX,diffY)
   translateX(diffX)
   translateY(diffY)

13)
   Para crear un proyecto con libgdx desde cero, seguir este link:
   http://libgdx.badlogicgames.com/documentation/gettingstarted/Importing%20into%20IDE.html

14)
    On Android, a Sound instance can not be over 1mb in size. If you have a bigger file, use Music

15)
    Cuando estoy invulnerable durante unos segundos por haber perdido una vida, no programar el
    poder agarrar items, porque eso cambia los filtros y me dejan vulnerable dependiendo del poder.

16)
    Debo hacer dispose de las cosas a las que les hice new. Si yo no les hice new (por ejemplo las texturas), no
    es mi responsabilidad (es la responsabilidad del assetManager).

17)
    Within my game's render(), I first call my entityUpdate(delta), which updates and moves all of the objects in my game scaled by the distance
    traveled in time "delta" (it doesn't render them, just moves their position variables).
    Then I call entityManageCollisions(delta), which resolves all of the collisions caused by the update, then I finally call entityDraw(batch, delta),
    which uses delta to get the right frames for sprite animations, and actually draws everything on the screen.

18)
    No estoy seguro, pero para generar un apk release no firmado:
    Abrir el archivo android/build.grandle y clickear adentro.
    Se me habilita en el menu build la opcion Select Build Variant...
    Alli elijo Release, luego en el menu Build selecciono Build APK.

    Si hago cambios en los archivos .grandle, debo luego hacer un Rebuild project para que sean tomados en cuenta.
    Esto es para usar el ide, sino seria ejecutar las tareas gradle:
    Information:Gradle tasks [:android:assembleRelease, :core:assemble, :desktop:assemble]

    Para quitar el folder raw de los apk (tanto en debug como release), agregue en android/build.grandle:
    android {
        aaptOptions {
            ignoreAssetsPattern '!raw'
        }
    Para quitar el folder raw del jar (desktop) agregue en desktop/build.grandle:
    task dist(type: Jar) {
        ...
        exclude '**/raw/**'

    También seguí la información de esta guia (sección Tweaking) para generar jars (desktop) renombrados con fecha y hora:
    https://github.com/libgdx/libgdx/wiki/Gradle-on-the-Commandline
    salida ejemplo: gameThree-1.0-build-20180220_223045.jar

    Para generar los apks renombrados con informacion de version agregue en android/build.grandle:
    android {
    ...
        // Rename all output artifacts to include version information
        applicationVariants.all { variant ->
            variant.outputs.each { output ->
                def apkName = "gameThree_" + android.defaultConfig.versionName;
                if (variant.buildType.name.equals("release")) {
                    apkName += "_" + variant.buildType.name;
                }
                apkName += ".apk";
                output.outputFile = file("$project.buildDir/apk/" + apkName)
            }
        }
    }

    salida ejemplo: gameThree_1.0-build-20180220_221710.apk

    Finalmente, para optimizar el tamaño del apk leí la info de esta guía:
    https://developer.android.com/topic/performance/reduce-apk-size.html

    Agregué en android/build.grandle:
        buildTypes {
            debug {
                minifyEnabled true
                shrinkResources true
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
            release {
                minifyEnabled true
                shrinkResources true
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
        }

    Lo interesante además es el uso de la herramienta pngcrush.exe, que reduce el tamaño de los pngs.
    Si reduzco los dynamicObjects.png, gano algo así como medio mega en total.
    Pero la reducción más drástica se da con background.png (de cada nivel) en donde gano más de 2 megas.
    Para usar esa herramienta hice:
    >pngcrush.exe background.png salidaBackground.png

    De todos modos, lo mejor que encontre para reducir el tamano de las imagenes es usar TinyPng. Lo tiene
    integrado el TexturePacker, basta con hacerse una cuenta en TinyPng y obtener una clave para usar sus
    servicios. Eligiendo TinyPng en el combo del TexturePacker, reduzco todos los dynamicObjects. Para backgroud.png
    debo usar el curl (para invocar al servicio) porque la imagen es mayor a 5 megas (sino podria usar directo el
    sitio web).

19)
    A dynamic body is a body which is affected by world forces and react to collisions. And you already met a million of them.
    A static body is a body which isn’t affected by world forces it does not react to collisions. It can’t be moved. Fullstop.
    A kinematic body is an hybrid body which is not affected by forces and collisions like a static body but can moved
    with a linear velocity like a dynamic body.

20)
   Mi criterio es el siguiente: En los eventos invocados por WorldContactListener.beginContact solo seteo estados. No toco velocidades ni nada, ni mucho menos toco el box2d.
   "No b2body can be changed when the simulation is occurring, we must wait for the next update cycle."
   En los update, según el estado es que cambio velocidades, posiciones, box2d, etc. Ese es mi criterio.
   Por eso por ejemplo en EnemyOne aparecen cosas como b2body.setLinearVelocity(velocity) dentro de stateAlive(float dt).
   Toco velocidades directamente dentro de WorldContactListener en endContact, porque al parecer allí es seguro (solo lo hago al invocar Hero.stop()).

21)
   Con setBound defino su tamaño y luego, si quiero, son setPosition su posición. Esta ultima tiene sentido llamarla si deseo cambiar la posición del sprite, por ejemplo,
   para alinearla con su box2d después de la simulación física.

22) setRotation, angle() y lpmqtrmpc:
    Si tengo un vector y hago vector.angle() eso me devuelve el ángulo que forma el vector puesto en el punto (0, 0) con respecto al eje x, medido en sentido antihorario. Punto, se acabó.
    Este es el sistema de coordenadas:
                    90
                    |
                    |
     cuadrante II   |  cuadrante I
                    |
      180 ----------|---------- 0/360
                    |
                    |
     cuadrante III  |  cuadrante IV            |
                    |
                   270

    Cuando dibujo una textura con el método draw(Batch batch) de la clase Sprite, se dibuja paradita tal cual la veo en mis archivos de imágenes.
    Si utilizo el método draw de la clase Batch, ahí la dibuja acostada sobre el eje x y mirando hacia la derecha.
    Se puede decir entonces que Sprite.draw() es equivalente a Batch.draw() + setRotation(90).
    En lo posible debo usar siempre Sprite.draw() que como comenté antes, dibuja la textura tal cual la veo en mis archivos (paradita).
    Si hago Sprite.setRotation(), eso la rota en sentido antihorario, si hago Sprite.rotation() la rota también en sentido antihorario pero permite acumular rotaciones.
    Entonces Sprite.rotation(20) + Sprite.rotation(30) = Sprite.setRotation(50).

    Lo divertido de esto, es que si tengo un vector velocidad vel que está en el cuadrante I apuntando hacia afuera, y quiero hacer que mi textura (supongamos un hombrecito)
    mire hacia ese lugar, como los angulos se rotan antihorario y se miden antihorario y la textura de Sprite.draw() está "rotada 90 con respecto a la matemática" debo hacer:
    anguloAGirarTextura = 90 (cuadrante II) + 90 (cuadrante III) + 90 (cuadrante IV) + vel.angle();
    sprite.setRotation(anguloAGirarTextura)

    Si el vector velocidad está en los cuadrantes II, III y IV:
    anguloAGirarTextura = vel.angle() - 90 (cuadrante I);
    sprite.setRotation(anguloAGirarTextura)

    Libgdx no trabaja con ángulos negativos aunque al parecer es robusto y los giros de ángulos negativos lo hace en sentido horario. No usar ángulos negativos porque es impredecible para mi.
    No se si alguna vez vector.angle() retorna exactamente cero o exactamente 360. Creo que puede llegar a retornar cero pero no 360. Es decir, no conozco ese valor borde.

23)
    Given a range between Max and Min, the following is the general formula for generating random numbers between a given minimum and maximum number:

    (Max - Min) * random(0 to 1) + Min = random(Min to Max)

24)
    El tamaño grande del apk se debe principalmente a las imágenes y al audio.
    Para comprimir las imágenes usar Texture Packer seleccionando "Compression TinyPNG".
    Para usarlo debo tener una key de developer (7yaS9nq0e-PmOCid1k6me6gk_bjTamPq). La conseguí yendo
    al sitio https://tinypng.com/developers y registrando mi direccion de correo. Te envian un mail
    en donde podes ver cuantas imágenes llevas comprimidas (maximo 500 por mes): https://tinypng.com/dashboard/developers
    Para reducir background.png no lo puedo hacer por la web de tinypng.com porque es muy pesada.
    Utilizo curl para poder usar la api como servicio:
    C:\Alvaro\Develop\Android\20171202\Texturepacker\curl-7.59.0\I386>enviarImagen.bat background.png
    Eso después de un rato genera esta salida:

    C:\Alvaro\Develop\Android\20171202\Texturepacker\curl-7.59.0\I386>curl --user api:7yaS9nq0e-PmOCid1k6me6gk_bjTamPq --data-binary @background.png -i https://api.tinify.com/shrink
    HTTP/1.1 100 Continue

    HTTP/1.1 201 Created
    Date: Tue, 27 Mar 2018 00:38:42 GMT
    Content-Type: application/json
    Content-Length: 203
    Connection: keep-alive
    Compression-Count: 7
    Cache-Control: no-cache
    Location: https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq

    {"input":{"size":7833078,"type":"image/png"},"output":{"size":1351755,"type":"image/png","width":2048,"height":2048,"ratio":0.1726,"url":"https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq"}}

    Entonces si voy a la url que alli dice (https://api.tinify.com/output/htkrx9ru6pjp1heyz4q5grx6egk7bxmq) puedo bajar mi imagen reducida.

25)
    Por lo que vi, mi delta time (dt) anda por 0.025, a veces menos (0.01algo)

26)
    A veces los ogg no se escuchan, para ello debo modificar su tasa de muestreo a 44100hz.
    Para subir el volumen a un ogg, con Audacity modificar la barrita a la izquierda que dice - +.

27)
    AbstractScreen implementa Screen y extiende Stage (Scene2d).
    Sea x una pantalla que extiende de AbstractScreen.
    Entonces, x.buildStage arma todo los actores de esa pantalla, es como el constructor.
    Luego si yo hago game.setScreen(x), libgdx invoca al render de Game que invoca al render de x.
    El render de x está definido en AbstractScreen e invoca al act y al draw de Stage.
    Yo hago game.setScreen dentro de ScreenManager y luego esta última hace x.dispose.
    ScreenManager maneja pantallas sobre las cuales navego, como el MainMenuScreen, PlayScreen, GameOverScreen, etc.
    El Hud la considero como una pantalla más, que extiende AbstractScreen (pues tiene camara como MainMenuScreen, GameOverScreen, etc.).
    Pero como no es administrada por ScreenManager, jamás se hace un game.setScreen(Hud), por ende, jamás se invoca al render de AbstractScreen.
    En este caso particular, como el Hud depende pura y exclusivamente de PlayScreen, es PlayScreen la que invoca a su buildStage, act, draw y
    dispose. Es decir, es PlayScreen la que haría lo que haría ScreenManager para el resto de las pantallas como MainMenuScreen, GameOverScreen, etc.

IOS
---
xcode para programar en objectiveC o en swift.
xcode funciona en mac, se usa un emulador para probar iphone o sino enchufar un iphone.
La licencia al parecer ahora es gratis.
Tengo links en bookmarks libgdx en donde habla de las opciones libgdx ios.
